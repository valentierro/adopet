generator client {
  provider = "prisma-client-js"
  // Dentro de api/ para a função serverless; copiado para dist/api no build (Vercel)
  output   = "../api/prisma-generated"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id           String    @id @default(uuid())
  email        String    @unique
  username     String?   @unique // @nome para identificar na hora de indicar adotante (ex.: @maria.silva)
  passwordHash String?
  name         String
  avatarUrl    String?
  phone        String?
  city         String?
  bio          String?   // texto curto sobre o usuário (ex: "Amo animais, quero adotar")
  housingType  String?   // CASA | APARTAMENTO — para o anunciante avaliar
  hasYard      Boolean?  // tem quintal
  hasOtherPets Boolean?  // tem outros pets
  hasChildren  Boolean?  // tem crianças em casa
  timeAtHome   String?   // MOST_DAY | HALF_DAY | LITTLE — quanto tempo passa em casa
  petsAllowedAtHome     String?   // YES | NO | UNSURE — pets permitidos no local (condomínio/locador)
  dogExperience        String?   // NEVER | HAD_BEFORE | HAVE_NOW — experiência com cachorro
  catExperience        String?   // NEVER | HAD_BEFORE | HAVE_NOW — experiência com gato
  householdAgreesToAdoption String?   // YES | DISCUSSING — todos em casa concordam com a adoção
  whyAdopt              String?   @db.VarChar(500) // por que quer adotar (texto livre para triagem)
  activityLevel         String?   // LOW | MEDIUM | HIGH — nível de atividade (para match com energyLevel do pet)
  preferredPetAge       String?   // PUPPY | ADULT | SENIOR | ANY — idade preferida do pet
  commitsToVetCare      String?   // YES | NO — compromisso com cuidados veterinários (match com pet hasSpecialNeeds)
  walkFrequency         String?   // DAILY | FEW_TIMES_WEEK | RARELY | NOT_APPLICABLE — frequência de passeios
  monthlyBudgetForPet   String?   // LOW | MEDIUM | HIGH — orçamento mensal para o pet (match com hasOngoingCosts)
  pushToken    String?   // Expo push token para notificações
  emailVerificationToken String?   // token para confirmar e-mail (limpo após confirmação)
  emailVerifiedAt        DateTime? // quando o e-mail foi confirmado
  deactivatedAt DateTime? // soft delete: conta desativada (auto ou banido por admin)
  bannedAt      DateTime? // quando admin aplicou ban (sem denúncia ou direto)
  bannedById    String?   // id do admin que baniu
  bannedReason  String?   @db.Text // motivo opcional do ban
  lastListingReminderAt DateTime? // último envio de push "atualize seus anúncios" (follow-up tutores)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  pets         Pet[]
  swipes       Swipe[]
  favorites    Favorite[]
  messages     Message[]
  conversations ConversationParticipant[]
  preferences  UserPreferences?
  refreshTokens RefreshToken[]
  reportsCreated Report[]
  blocksGiven   Block[]    @relation("BlockBlocker")
  blocksReceived Block[]    @relation("BlockBlocked")
  verifications Verification[]
  savedSearches SavedSearch[]
  adoptionsAsTutor   Adoption[] @relation("AdoptionsAsTutor")
  adoptionsAsAdopter Adoption[] @relation("AdoptionsAsAdopter")
  petsPendingAsAdopter Pet[]    @relation("PetPendingAdopter")
  bugReports          BugReport[]
  partner             Partner?  // conta parceiro (se for parceiro pago)
  partnerMemberships  PartnerMember[]  // membro de ONG (não é dono do portal)
  partnerRecommendations PartnerRecommendation[]
  inAppNotifications  InAppNotification[]
  petViews            PetView[]
}

model InAppNotification {
  id        String    @id @default(uuid())
  userId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  type      String    // PARTNERSHIP_ENDED_ONG | PARTNERSHIP_ENDED_PAID_SCHEDULED | PARTNERSHIP_ENDED_PAID_TODAY
  title     String
  body      String    @db.Text
  metadata  String?   @db.Text // JSON: { partnerName?, periodEndFormatted? }
  readAt    DateTime?
  createdAt DateTime  @default(now())
  @@index([userId])
  @@index([userId, readAt])
}

model UserPreferences {
  id               String   @id @default(uuid())
  userId           String   @unique
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  species          String   @default("BOTH") // DOG | CAT | BOTH
  radiusKm         Int      @default(50)
  sizePref         String?  // BOTH | small | medium | large | xlarge (para recomendação)
  sexPref          String?  // BOTH | male | female — preferência de sexo do pet (match)
  latitude         Float?   // última localização (para notificação "novos pets na região")
  longitude        Float?
  notifyNewPets           Boolean  @default(true)
  notifyMessages         Boolean  @default(true)
  notifyReminders        Boolean  @default(true)
  notifyListingReminders Boolean  @default(true) // lembretes para atualizar anúncios (a cada ~30 dias)
  updatedAt              DateTime @updatedAt
}

model SavedSearch {
  id         String   @id @default(uuid())
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  species    String?  // DOG | CAT | BOTH
  size       String?  // small | medium | large | xlarge
  breed      String?
  latitude   Float?
  longitude  Float?
  radiusKm   Int      @default(50)
  lastCheckedAt DateTime @default(now())
  createdAt  DateTime @default(now())
  @@index([userId])
}

model RefreshToken {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  tokenHash String
  expiresAt DateTime
  createdAt DateTime @default(now())
  @@index([userId])
  @@index([tokenHash])
}

model PartnershipRequest {
  id                String    @id @default(uuid())
  tipo              String    // ong | comercial
  nome              String
  email             String
  instituicao       String
  telefone          String
  mensagem          String?
  cnpj              String?
  anoFundacao       String?
  cep               String?
  endereco          String?
  personType        String?   // PF | CNPJ
  documentoComercial String?
  planoDesejado     String?
  status            String    @default("PENDING") // PENDING | APPROVED | REJECTED
  rejectionReason   String?
  processedAt       DateTime?
  partnerId         String?   // preenchido quando aprovado (parceiro criado)
  partner           Partner?  @relation(fields: [partnerId], references: [id], onDelete: SetNull)
  createdAt         DateTime  @default(now())
  @@index([status])
}

model Partner {
  id                   String    @id @default(uuid())
  userId               String?   @unique // dono da conta parceiro (cadastro pelo app + pagamento)
  user                 User?     @relation(fields: [userId], references: [id], onDelete: SetNull)
  type                 String    // ONG | CLINIC | STORE
  partnershipRequests  PartnershipRequest[]
  name                 String
  slug                 String    @unique
  city                 String?
  description          String?
  website              String?
  logoUrl              String?
  phone                String?
  email                String?
  address              String?   // endereço completo (portal parceiro)
  documentType         String?   // CPF | CNPJ (parceiro comercial)
  document             String?   // número do documento (apenas dígitos)
  legalName            String?   // razão social (quando CNPJ)
  tradeName            String?   // nome fantasia (quando CNPJ)
  galleryUrls          String?   // JSON array de URLs de fotos do estabelecimento
  active               Boolean   @default(true)
  approvedAt           DateTime?
  activatedAt          DateTime? // primeiro login do parceiro no app (parceria só "ativa" após isso)
  rejectionReason      String?   // motivo da rejeição (admin)
  isPaidPartner        Boolean   @default(false)
  subscriptionStatus   String?   // active | canceled | past_due | trialing (Stripe)
  stripeCustomerId     String?
  stripeSubscriptionId String?
  planId               String?   // BASIC | DESTAQUE | PREMIUM
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt
  pets                 Pet[]
  coupons              PartnerCoupon[]
  services             PartnerService[]
  events               PartnerEvent[]
  members              PartnerMember[]  // membros da ONG (só type=ONG)
  @@index([type])
  @@index([active, type])
  @@index([userId])
}

model PartnerMember {
  id         String   @id @default(uuid())
  partnerId  String
  partner    Partner  @relation(fields: [partnerId], references: [id], onDelete: Cascade)
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  role       String?  // função na ONG: VOLUNTARIO | COORDENADOR | CUIDADOR | RECEPCIONISTA | VETERINARIO | ADMINISTRATIVO | OUTRO
  createdAt  DateTime @default(now())
  @@unique([partnerId, userId])
  @@index([partnerId])
  @@index([userId])
}

model PartnerCoupon {
  id          String   @id @default(uuid())
  partnerId   String
  partner     Partner  @relation(fields: [partnerId], references: [id], onDelete: Cascade)
  code        String   // código do cupom (ex: ADOPET10)
  title       String?  // título exibido (ex: "10% em ração")
  description String?
  discountType String  @default("PERCENT") // PERCENT | FIXED
  discountValue Decimal @db.Decimal(10, 2) // percentual (10) ou valor fixo em centavos (1000 = R$ 10)
  validFrom   DateTime @default(now())
  validUntil  DateTime?
  active      Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  @@index([partnerId])
  @@index([partnerId, active])
}

model PartnerService {
  id          String    @id @default(uuid())
  partnerId   String
  partner     Partner   @relation(fields: [partnerId], references: [id], onDelete: Cascade)
  name        String    // ex: "Banho e tosa"
  description String?
  priceDisplay String?  // ex: "A partir de R$ 50" ou "Sob consulta"
  imageUrl    String?   // foto do serviço (opcional)
  active      Boolean   @default(true)
  validUntil  DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  @@index([partnerId])
  @@index([partnerId, active])
}

model PartnerEvent {
  id        String   @id @default(uuid())
  partnerId String
  partner   Partner  @relation(fields: [partnerId], references: [id], onDelete: Cascade)
  eventType String   // profile_view | coupon_copy
  couponId  String?  // preenchido quando eventType = coupon_copy
  createdAt DateTime @default(now())
  @@index([partnerId])
  @@index([partnerId, createdAt])
}

model Pet {
  id              String    @id @default(uuid())
  name            String
  species         String
  breed           String?   // raça opcional (ex: Golden, SRD, Persa)
  age             Int
  sex             String
  size            String
  vaccinated      Boolean
  neutered        Boolean
  description     String
  adoptionReason  String?   // por que está doando (opcional)
  feedingType     String?   // seca, úmida, mista, natural, outra (opcional)
  feedingNotes    String?   // alergias, dieta especial, observações (opcional)
  energyLevel     String?   // LOW | MEDIUM | HIGH — nível de energia (calmo / moderado / agitado)
  healthNotes     String?   @db.VarChar(500) // comorbidades, necessidades especiais (texto livre)
  hasSpecialNeeds Boolean?  // necessita cuidados especiais
  goodWithDogs    String?   // YES | NO | UNKNOWN — se dá bem com outros cachorros
  goodWithCats    String?   // YES | NO | UNKNOWN — se dá bem com gatos
  goodWithChildren String?  // YES | NO | UNKNOWN — se dá bem com crianças
  temperament     String?   // CALM | PLAYFUL | SHY | SOCIABLE | INDEPENDENT — temperamento
  isDocile        Boolean?  // é dócil (manso/calmo com pessoas)
  isTrained       Boolean?  // é adestrado
  // Preferência de tutor (para engine de match adotante x pet); null = não informar
  preferredTutorHousingType       String?   // CASA | APARTAMENTO | INDIFERENTE
  preferredTutorHasYard           String?   // SIM | NAO | INDIFERENTE — prefere tutor com quintal
  preferredTutorHasOtherPets      String?   // SIM | NAO | INDIFERENTE — OK com outros pets no local
  preferredTutorHasChildren       String?   // SIM | NAO | INDIFERENTE — OK com crianças em casa
  preferredTutorTimeAtHome       String?   // MOST_DAY | HALF_DAY | LITTLE | INDIFERENTE
  preferredTutorPetsAllowedAtHome String?   // YES | NO | UNSURE — pets permitidos no local
  preferredTutorDogExperience    String?   // NEVER | HAD_BEFORE | HAVE_NOW
  preferredTutorCatExperience    String?   // NEVER | HAD_BEFORE | HAVE_NOW
  preferredTutorHouseholdAgrees  String?   // YES | DISCUSSING
  preferredTutorWalkFrequency    String?   // DAILY | FEW_TIMES_WEEK | RARELY | INDIFERENTE — prefere tutor que passeie
  hasOngoingCosts               Boolean?  // pet tem gastos contínuos (medicação, ração especial) — match com orçamento
  status          String    @default("AVAILABLE") // AVAILABLE | IN_PROCESS | ADOPTED
  markedAdoptedAt DateTime? // quando o tutor marcou como adotado; após 48h sem registro manual (e após adotante confirmar), sistema auto-valida
  pendingAdopterId String?  // adotante indicado pelo tutor ao marcar como adotado (lista de conversas ou @username)
  adopterConfirmedAt DateTime? // quando o adotante confirmou no app que realizou a adoção; só então vai para painel admin / auto-approve
  adoptionRejectedAt DateTime? // quando um admin rejeitou a marcação de adoção; pet volta a disponível e exibe badge "Rejeitado pelo Adopet"
  adoptionRejectionReason String? // motivo opcional quando admin rejeita a marcação de adoção (exibido ao tutor)
  adopetConfirmedAt  DateTime? // quando a Adopet confirmou a adoção (admin ou auto-approve 48h); só então exibe badge "Confirmado pelo Adopet"
  postAdoptionFeedbackPushSentAt DateTime? // quando enviamos push "Como foi a adoção?" (uma vez, dias após confirmação)
  publicationStatus String  @default("PENDING")   // PENDING | APPROVED | REJECTED — feed só mostra APPROVED
  publicationRejectionReason String? // motivo opcional quando admin rejeita o anúncio (exibido ao tutor)
  expiresAt        DateTime? // vida útil do anúncio (60 dias); null = legado; feed só mostra se expiresAt > now
  expiryReminder10SentAt DateTime? // aviso "expira em 10 dias" já enviado
  expiryReminder5SentAt  DateTime?
  expiryReminder1SentAt  DateTime?
  latitude        Float?
  longitude       Float?
  city            String?   // cidade do anúncio (reverse geocode das coordenadas); card do feed usa isso
  ownerId         String
  owner           User      @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  partnerId       String?   // ONG parceira (anúncio em parceria)
  partner         Partner?  @relation(fields: [partnerId], references: [id], onDelete: SetNull)
  pendingAdopter   User?     @relation("PetPendingAdopter", fields: [pendingAdopterId], references: [id], onDelete: SetNull)
  media           PetMedia[]
  adoption        Adoption? // registro de adoção (tutor + adotante) quando preenchido
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  swipes          Swipe[]
  favorites       Favorite[]
  conversations   Conversation[]
  views           PetView[]

  @@index([publicationStatus, status, id])
  @@index([publicationStatus, status, expiresAt, id])
  @@index([ownerId])
}

model Adoption {
  id         String   @id @default(uuid())
  petId      String   @unique // um pet só pode ser adotado uma vez
  pet        Pet      @relation(fields: [petId], references: [id], onDelete: Cascade)
  tutorId    String   // dono do pet no momento da adoção (ownerId)
  tutor      User     @relation("AdoptionsAsTutor", fields: [tutorId], references: [id], onDelete: Cascade)
  adopterId  String   // usuário que adotou
  adopter    User     @relation("AdoptionsAsAdopter", fields: [adopterId], references: [id], onDelete: Cascade)
  adoptedAt  DateTime @default(now())
  createdAt  DateTime @default(now())
  @@index([tutorId])
  @@index([adopterId])
  @@index([adoptedAt])
}

model PetMedia {
  id        String  @id @default(uuid())
  petId     String
  pet       Pet     @relation(fields: [petId], references: [id], onDelete: Cascade)
  url       String
  sortOrder Int     @default(0)
  isPrimary Boolean @default(false)
}

model Swipe {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  petId     String
  pet       Pet      @relation(fields: [petId], references: [id], onDelete: Cascade)
  action    String   // LIKE | PASS
  createdAt DateTime @default(now())
  @@unique([userId, petId])
}

model Favorite {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  petId     String
  pet       Pet      @relation(fields: [petId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  @@unique([userId, petId])
  @@index([userId, createdAt])
}

model PetView {
  id                   String    @id @default(uuid())
  petId                String
  pet                  Pet       @relation(fields: [petId], references: [id], onDelete: Cascade)
  userId               String
  user                 User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  viewedAt             DateTime  @default(now())
  revisitedFromPassedAt DateTime? // quando o usuário abriu o detalhe pela tela "Pets que passou" (conta +1 por usuário, atualizado a cada acesso)
  @@unique([petId, userId])
  @@index([petId, viewedAt])
}

model Conversation {
  id                String    @id @default(uuid())
  petId             String
  pet               Pet       @relation(fields: [petId], references: [id], onDelete: Cascade)
  adopterId         String?   // quem favoritou e iniciou a conversa (NORMAL) ou adotante a confirmar (ADOPTION_CONFIRMATION)
  type              String    @default("NORMAL") // NORMAL | ADOPTION_CONFIRMATION (conversa com Adopet para confirmar adoção)
  participants      ConversationParticipant[]
  messages          Message[]
  lastReminderAt    DateTime? // último envio de lembrete "conversa pendente"
  listingRemovedAt  DateTime? // anúncio expirou por falta de prorrogação; exibir aviso no chat
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  @@unique([petId, adopterId, type])
  @@index([updatedAt])
}

model ConversationParticipant {
  id             String       @id @default(uuid())
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  userId         String
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@unique([conversationId, userId])
}

model Message {
  id             String       @id @default(uuid())
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  senderId       String?      // null = mensagem de sistema (ex.: anúncio expirado)
  sender         User?        @relation(fields: [senderId], references: [id], onDelete: Cascade)
  isSystem       Boolean      @default(false)
  content        String       @default("")
  imageUrl       String?      // foto enviada no chat
  readAt         DateTime?
  createdAt      DateTime     @default(now())
  @@index([conversationId, createdAt])
}

model Report {
  id                  String    @id @default(uuid())
  reporterId          String
  reporter            User      @relation(fields: [reporterId], references: [id], onDelete: Cascade)
  targetType          String    // USER | PET | MESSAGE
  targetId            String
  reason              String
  description         String?
  resolvedAt          DateTime? // preenchido quando admin resolve a denúncia
  resolvedById        String?   // admin que resolveu
  resolutionFeedback  String?   // feedback para o denunciador (opcional)
  resolutionAction    String?   // ex.: BAN_USER quando admin optou por banir o usuário denunciado
  createdAt           DateTime  @default(now())
  @@index([targetType, targetId])
  @@index([targetType, resolvedAt])
  @@index([reporterId])
}

model Block {
  id           String   @id @default(uuid())
  blockerId    String
  blocker      User     @relation("BlockBlocker", fields: [blockerId], references: [id], onDelete: Cascade)
  blockedUserId String
  blockedUser   User     @relation("BlockBlocked", fields: [blockedUserId], references: [id], onDelete: Cascade)
  createdAt    DateTime @default(now())
  @@unique([blockerId, blockedUserId])
  @@index([blockerId])
  @@index([blockedUserId])
}

model Verification {
  id               String   @id @default(uuid())
  userId           String
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  type             String   // USER_VERIFIED | PET_VERIFIED
  status           String   // PENDING | APPROVED | REJECTED
  rejectionReason  String?  // motivo opcional quando admin rejeita (exibido ao usuário)
  metadata         Json?    // para PET_VERIFIED: { "petId": "..." }
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  @@index([userId])
  @@index([userId, type])
}

model BugReport {
  id          String   @id @default(uuid())
  userId      String?
  user        User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  type        String   @default("BUG") // BUG | SUGGESTION
  message     String
  stack       String?
  screen      String?
  userComment String?
  createdAt   DateTime @default(now())
  @@index([createdAt])
  @@index([type])
}

model PartnerRecommendation {
  id               String   @id @default(uuid())
  indicadorUserId  String
  indicador        User     @relation(fields: [indicadorUserId], references: [id], onDelete: Cascade)
  suggestedName    String   // nome do estabelecimento/ONG indicado
  suggestedType    String   // ONG | CLINIC | STORE
  suggestedCity    String?
  suggestedEmail   String?
  suggestedPhone   String?
  message         String?  // comentário do indicador
  createdAt       DateTime @default(now())
  @@index([indicadorUserId])
  @@index([createdAt])
}

model FeatureFlag {
  id          String   @id @default(uuid())
  key         String   @unique // ex: REQUIRE_EMAIL_VERIFICATION, ENABLE_NEW_FEATURE
  enabled     Boolean  @default(false)
  description String?  // texto para o admin entender o que a flag faz
  updatedAt   DateTime @updatedAt
}
